<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Outdoor WebXR AR Navigation (True‑North Aligned)</title>

  
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.155.0/build/three.module.js"
      }
    }
  </script>

  <style>
    html,body{
      margin:0; padding:0; height:100%; font-family:sans-serif;
      background:#000; color:#fff; overflow:hidden;
    }
    #ui{
      position:fixed; top:0; left:0; width:100%; padding:12px; box-sizing:border-box;
      display:flex; gap:12px; align-items:center; z-index:2; pointer-events:auto;
    }
    button{
      background:#0af; border:none; padding:8px 16px; border-radius:8px; color:#fff;
      font-size:1rem; cursor:pointer;
    }
    #status{flex:1;font-size:.9rem;opacity:.8;}
    #canvas{position:fixed; top:0; left:0; width:100%; height:100%; z-index:1;}
  </style>
</head>
<body>
  <div id="ui">
    <button id="startBtn">Start AR Navigation</button>
    <button id="stopBtn" style="display:none;">Stop Navigation</button>
    <span id="status">Waiting for GPS…</span>
  </div>
  <canvas id="canvas"></canvas>

  <script type="module">
    import * as THREE from 'three';

    
    const canvas       = document.getElementById('canvas');
    const startBtn     = document.getElementById('startBtn');
    const stopBtn      = document.getElementById('stopBtn');
    const statusEl     = document.getElementById('status');

    let renderer, scene, camera;
    let xrSession, refSpace;
    let worldRoot;                    // Rotates to align with TRUE NORTH
    let lineMesh;                     // THREE.Line representing route

    // Geospatial
    let originLLA   = null;           // {lat, lon, alt}
    let waypointsLLA = [];            // Raw from server → [{lat,lng,alt,id}, …]
    let waypointsENU = [];            // Converted → [{x,y,z,id}, …]

    // Live user state
    let userLLA = null;               // {lat, lon, alt}
    let userENU = new THREE.Vector3();

    // Heading
    let currentHeadingDeg = 0;        // Real‑time compass heading (0° = North)
    let initialHeadingDeg = null;     // Captured the moment we enter XR → defines world‑north

    // Constants
    const EARTH_RADIUS = 6378137;     // metres, spherical approx.
    const DEG2RAD      = Math.PI/180;

    
    async function fetchWaypointsFromServer(origin){
      // Replace with real REST call. For demo, hard‑code three points ~100 m apart
      await new Promise(r=>setTimeout(r,500));
      return [
        {...origin, id:'start'},                                        // "waypoint 0" (user)
        {lat:origin.lat+0.0005, lng:origin.lng+0.0002, alt:origin.alt, id:'wp1'},
        {lat:origin.lat+0.0010, lng:origin.lng+0.0004, alt:origin.alt, id:'wp2'}
      ];
    }

    
    let geoWatchId   = null;
    const geoBuffer  = [];

    function startGeolocation(){
      if(!('geolocation' in navigator)){
        statusEl.textContent = 'Geolocation not supported.';
        return;
      }
      geoWatchId = navigator.geolocation.watchPosition(pos=>{
        const {latitude:lat, longitude:lng, altitude:altitudeRaw} = pos.coords;
        const alt = altitudeRaw || 0;
        geoBuffer.push({lat,lng,alt});
        if(geoBuffer.length>3) geoBuffer.shift();   // keep last 3

        // Simple smoothing (mean)
        const smooth = geoBuffer.reduce((acc,v)=>{
          acc.lat+=v.lat; acc.lng+=v.lng; acc.alt+=v.alt; return acc;
        },{lat:0,lng:0,alt:0});
        smooth.lat/=geoBuffer.length;
        smooth.lng/=geoBuffer.length;
        smooth.alt/=geoBuffer.length;

        userLLA = smooth;
        if(!originLLA){
          originLLA = {...smooth};        // set session origin first time we have a fix
          loadWaypointsAndInit();
        }
      }, err=>{
        statusEl.textContent = 'GPS error: '+err.message;
      },{enableHighAccuracy:true, maximumAge:1000, timeout:5000});
    }

    
    const orientationEvt = ('ondeviceorientationabsolute' in window)
      ? 'deviceorientationabsolute':'deviceorientation';

    window.addEventListener(orientationEvt, (e)=>{
      // On some iOS devices we get webkitCompassHeading, use that preferentially.
      if(e.webkitCompassHeading !== undefined){
        currentHeadingDeg = e.webkitCompassHeading;  // 0 = north
      }else if(e.absolute && e.alpha !== null){
        // Convert α,β,γ (Z‑X′‑Y″) Euler angles → compass heading.
        // α is rotation around Z (0° = north). The formula below converts to 0..360°
        currentHeadingDeg = 360 - e.alpha;           // α increases clockwise → invert
      }
    }, true);

    
    function initThree(){
      renderer = new THREE.WebGLRenderer({canvas, alpha:true, antialias:true});
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.xr.enabled = true;

      scene  = new THREE.Scene();
      camera = new THREE.PerspectiveCamera();

      // Root group we rotate about Y so that scene +Z points toward TRUE NORTH
      worldRoot = new THREE.Group();
      scene.add(worldRoot);

      const light = new THREE.HemisphereLight(0xffffff, 0x444444, 1.0);
      scene.add(light);
    }

  
    function llaToENU(lla){
      const dLat = (lla.lat - originLLA.lat) * DEG2RAD;
      const dLon = (lla.lng - originLLA.lng) * DEG2RAD;
      const x    = dLon * Math.cos(originLLA.lat*DEG2RAD) * EARTH_RADIUS;  // East
      const z    = dLat * EARTH_RADIUS;                                    // North
      const y    = (lla.alt - originLLA.alt);                              // Up
      return new THREE.Vector3(x, y, z);
    }

    
    function buildPolyline(){
      if(lineMesh){ worldRoot.remove(lineMesh); lineMesh.geometry.dispose(); }
      if(waypointsENU.length<2) return;

      const positions = [];
      positions.push(userENU.x, userENU.y, userENU.z);
      for(const wp of waypointsENU){ positions.push(wp.x, wp.y, wp.z); }

      const geom = new THREE.BufferGeometry();
      geom.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));

      const mat  = new THREE.LineBasicMaterial({color:0xff00ff, linewidth:5});
      lineMesh   = new THREE.Line(geom, mat);
      worldRoot.add(lineMesh);
    }

    
    function onXRFrame(time, frame){
      const session = frame.session;
      session.requestAnimationFrame(onXRFrame);

      // Update user position → ENU
      if(userLLA){ userENU.copy( llaToENU(userLLA) ); }

      // Align worldRoot so its +Z is TRUE NORTH.
      if(initialHeadingDeg !== null){
        const headingDiff = currentHeadingDeg - initialHeadingDeg; // degrees
        worldRoot.rotation.set(0, -THREE.MathUtils.degToRad(headingDiff), 0);
      }

      // Rebuild polyline each frame so first vertex = live user pos
      if(lineMesh){
        const posAttr = lineMesh.geometry.getAttribute('position');
        posAttr.setXYZ(0, userENU.x, userENU.y, userENU.z);
        posAttr.needsUpdate = true;
      }

      renderer.render(scene, camera);
    }

    
    async function loadWaypointsAndInit(){
      if(!originLLA) return; // wait for first GPS fix
      statusEl.textContent = 'Fetching route…';
      waypointsLLA = await fetchWaypointsFromServer(originLLA);

      // Remove the first entry because that duplicates user position (we keep live one instead)
      waypointsLLA.shift();

      waypointsENU = waypointsLLA.map(llaToENU);
      statusEl.textContent = `Loaded ${waypointsENU.length} waypoints.`;
      startBtn.disabled = false;
    }

    
    async function startXR(){
      if(!navigator.xr){ alert('WebXR not supported on this device.'); return; }
      xrSession = await navigator.xr.requestSession('immersive-ar', {requiredFeatures:['local-floor']});
      renderer.xr.setReferenceSpaceType('local-floor');
      await renderer.xr.setSession(xrSession);
      refSpace = await xrSession.requestReferenceSpace('local-floor');

      // Capture the heading at the exact moment we enter XR. From now on this is considered 0°.
      initialHeadingDeg = currentHeadingDeg;

      xrSession.requestAnimationFrame(onXRFrame);
      buildPolyline();

      startBtn.style.display = 'none';
      stopBtn.style.display  = 'inline-block';
      statusEl.textContent   = 'AR session active';
    }

    function stopXR(){
      if(xrSession){ xrSession.end(); xrSession = null; }
      startBtn.style.display = 'inline-block';
      stopBtn.style.display  = 'none';
      statusEl.textContent   = 'Session ended';
    }

    
    startBtn.addEventListener('click', startXR);
    stopBtn .addEventListener('click', stopXR);

    initThree();
    startGeolocation();
  </script>
</body>
</html>
