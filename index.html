<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AR Navigation – Waypoint Edition (v2)</title>

    <!-- Three.js (non‑module build so it runs everywhere) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <style>
        /* ----------- visual + ui styles (unchanged) ------------- */
        *{margin:0;padding:0;box-sizing:border-box}
        body{font-family:"Segoe UI",Tahoma,Geneva,Verdana,sans-serif;background:#000;overflow:hidden;position:relative}
        #video{position:absolute;inset:0;width:100vw;height:100vh;object-fit:cover;z-index:1}
        #canvas{position:absolute;inset:0;width:100vw;height:100vh;z-index:2;pointer-events:none}
        .ui-overlay{position:absolute;z-index:3;color:#fff;font-weight:500}
        .top-bar{top:20px;left:20px;right:20px;display:flex;justify-content:space-between;align-items:center;background:rgba(0,0,0,.7);padding:15px 20px;border-radius:25px;backdrop-filter:blur(10px)}
        .destination-info{display:flex;align-items:center;gap:10px}
        .distance-time{font-size:18px;font-weight:bold}
        .eta{font-size:14px;opacity:.8}
        .compass{width:50px;height:50px;border:2px solid rgba(255,255,255,.3);border-radius:50%;display:flex;align-items:center;justify-content:center;position:relative}
        .compass-needle{width:3px;height:20px;background:#4285f4;border-radius:2px;transform-origin:bottom center;transition:transform .3s ease}
        .bottom-controls{bottom:30px;left:20px;right:20px;display:flex;justify-content:space-between;align-items:center}
        .control-btn{background:rgba(0,0,0,.8);border:none;color:#fff;padding:15px;border-radius:50%;cursor:pointer;backdrop-filter:blur(10px);transition:all .3s ease;display:flex;align-items:center;justify-content:center}
        .control-btn:hover{background:rgba(255,255,255,.2);transform:scale(1.1)}
        .center-crosshair{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);width:30px;height:30px;border:2px solid rgba(255,255,255,.6);border-radius:50%;z-index:4;pointer-events:none}
        .center-crosshair::before{content:"";position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);width:6px;height:6px;background:rgba(255,255,255,.8);border-radius:50%}
        .calibration-prompt{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,.9);color:#fff;padding:30px;border-radius:15px;text-align:center;backdrop-filter:blur(10px);z-index:5;display:none}
        .calibration-prompt.show{display:block}
        .status-indicator{position:absolute;top:100px;right:20px;background:rgba(0,0,0,.8);color:#fff;padding:10px 15px;border-radius:20px;font-size:12px;backdrop-filter:blur(10px)}
        .gps-accuracy{color:#4CAF50}.gps-searching{color:#FF9800}
        @keyframes pulse{0%{transform:scale(1);opacity:1}50%{transform:scale(1.25);opacity:.65}100%{transform:scale(1);opacity:1}}
    </style>
</head>
<body>
    <video id="video" playsinline autoplay muted></video>
    <canvas id="canvas"></canvas>

    <!-- cross‑hair & UI -->
    <div class="center-crosshair"></div>
    <div class="ui-overlay top-bar">
        <div class="destination-info">
            <div><div class="distance-time" id="distanceTime">Calculating…</div><div class="eta" id="eta">Getting directions…</div></div>
        </div>
        <div class="compass"><div id="compassNeedle" class="compass-needle"></div></div>
    </div>
    <div class="ui-overlay bottom-controls">
        <button class="control-btn" id="recenterBtn"   title="Re‑center">🔄</button>
        <button class="control-btn" id="calibrateBtn"  title="Calibrate">🧭</button>
    </div>
    <div class="ui-overlay status-indicator" id="statusIndicator"><span class="gps-searching">📡 Searching GPS…</span></div>
    <div class="calibration-prompt" id="calibrationPrompt"><h3>Compass calibration</h3><p>Move the phone in a figure‑8</p><button class="control-btn" onclick="hideCalibration()" style="margin-top:20px;border-radius:10px;padding:10px 20px;">Done</button></div>

<!-- =============================================================
   MAIN SCRIPT
============================================================== -->
<script>
// ========== GLOBALS ==========
let scene,camera,renderer,arrowGroup;
let currentPosition=null;        // live GPS fix
let waypoints=[];                // fetched from backend
let pathScale=0.08;              // metres → world‑units (overwritten later)
const WAYPOINT_API='https://waypoints-prht.onrender.com/get-waypoints/';

// ========== CAMERA (video background) ==========
async function initCamera(){
  const video=document.getElementById('video');
  const stream=await navigator.mediaDevices.getUserMedia({video:{facingMode:{ideal:'environment'}}});
  video.srcObject=stream;return new Promise(res=>video.onloadedmetadata=res);
}

// ========== THREE.JS SCENE ==========
function initThree(){
  const canvas=document.getElementById('canvas');
  renderer=new THREE.WebGLRenderer({canvas,alpha:true,antialias:true});
  renderer.setSize(window.innerWidth,window.innerHeight);
  renderer.setClearColor(0x000000,0);
  scene=new THREE.Scene();
  camera=new THREE.PerspectiveCamera(75,window.innerWidth/window.innerHeight,0.01,1000);
  camera.position.set(0,1.6,0); // ~eye height above virtual ground
  scene.add(new THREE.AmbientLight(0xffffff,0.7));
  const dir=new THREE.DirectionalLight(0xffffff,0.6);dir.position.set(10,20,10);scene.add(dir);
  arrowGroup=new THREE.Group();scene.add(arrowGroup);
}

// ========== DEVICE ORIENTATION ==========
function initDeviceOrientation(){
  const handle=e=>{
    const alpha=e.alpha??0,beta=e.beta??0,gamma=e.gamma??0;
    document.getElementById('compassNeedle').style.transform=`rotate(${360-alpha}deg)`;
    // apply yaw only → keep pitch/roll independent of compass drift
    camera.rotation.set(beta*Math.PI/180,alpha*Math.PI/180,0,'YXZ');
  };
  if(typeof DeviceOrientationEvent!=='undefined'&&DeviceOrientationEvent.requestPermission){
    DeviceOrientationEvent.requestPermission().then(r=>{if(r==='granted')window.addEventListener('deviceorientation',handle);});
  }else window.addEventListener('deviceorientation',handle);
}

// ========== GEOLOCATION ==========
function initGeolocation(){
  if(!('geolocation' in navigator))return;
  navigator.geolocation.watchPosition(p=>{
      currentPosition={lat:p.coords.latitude,lng:p.coords.longitude,acc:p.coords.accuracy};
      document.getElementById('statusIndicator').innerHTML=p.coords.accuracy<15?'<span class="gps-accuracy">📍 GPS ok</span>':'<span class="gps-searching">📡 Low accuracy</span>';
      moveSceneToUser();updateHUD();
    },e=>{
      document.getElementById('statusIndicator').textContent='GPS error';console.error(e);
    },{enableHighAccuracy:true,maximumAge:4000,timeout:10000});
}

// ========== FETCH + PREP WAYPOINTS ==========
async function loadWaypoints(){
  const id=new URLSearchParams(location.search).get('routeId');
  if(!id) return [];
  try{
    const j=await (await fetch(WAYPOINT_API+id)).json();
    return Array.isArray(j.waypoints)?j.waypoints:[];
  }catch(err){console.error('waypoint fetch',err);return [];} }

function metersBetween(a,b){const R=6371e3;const φ1=a.lat*Math.PI/180,φ2=b.lat*Math.PI/180,Δφ=(b.lat-a.lat)*Math.PI/180,Δλ=(b.lng-a.lng)*Math.PI/180;const h=Math.sin(Δφ/2)**2+Math.cos(φ1)*Math.cos(φ2)*Math.sin(Δλ/2)**2;return 2*R*Math.atan2(Math.sqrt(h),Math.sqrt(1-h));}
function geoToXY(origin,pt){const R=6371e3;const φ1=origin.lat*Math.PI/180,φ2=pt.lat*Math.PI/180,Δφ=(pt.lat-origin.lat)*Math.PI/180,Δλ=(pt.lng-origin.lng)*Math.PI/180;return{x:R*Δλ*Math.cos((φ1+φ2)/2),z:R*Δφ};}

function prepWaypoints(raw){
  if(!raw.length) return [];
  // 1. de‑bounce densely spaced points (<4 m)
  const filtered=[raw[0]];
  raw.forEach(wp=>{if(metersBetween(filtered.at(-1),wp)>4)filtered.push(wp);});
  // 2. convert to local coords
  const origin=filtered[0];
  return filtered.map(w=>({...w,rel:geoToXY(origin,w)}));
}

// ========== 3‑D MARKERS ==========
function mkArrow(){
  const s=new THREE.Shape();s.moveTo(-0.6,-0.5);s.lineTo(0,0.5);s.lineTo(0.6,-0.5);s.closePath();
  const m=new THREE.MeshLambertMaterial({color:0xffff00,transparent:true,opacity:0.95,side:THREE.DoubleSide});
  const mesh=new THREE.Mesh(new THREE.ShapeGeometry(s),m);
  mesh.rotation.x=-Math.PI/2;mesh.userData={t:Math.random()*Math.PI*2,base:1};
  return mesh;
}
function mkDestination(){
  const g=new THREE.Group();
  const cyl=new THREE.Mesh(new THREE.CylinderGeometry(0.45,0.35,0.6,6),new THREE.MeshLambertMaterial({color:0xb0122b,emissive:0xb0122b,emissiveIntensity:0.4}));
  const core=new THREE.Mesh(new THREE.CylinderGeometry(0.18,0.18,0.1,6),new THREE.MeshLambertMaterial({color:0xffffff}));core.position.y=0.33;
  const tip=new THREE.Mesh(new THREE.ConeGeometry(0.12,0.45,14),cyl.material);tip.position.y=-0.45;
  g.add(cyl,core,tip);g.position.y=0.2;return g;
}

// ========== BUILD 3‑D PATH ==========
function buildPath(){
  arrowGroup.clear();if(!waypoints.length) return;
  // scale so farthest point ~25 world‑units from origin
  const maxDist=Math.max(...waypoints.map(w=>Math.hypot(w.rel.x,w.rel.z)));
  pathScale=25/Math.max(maxDist,25); // cap to avoid tiny scale on short routes

  // destination pin
  const dst=waypoints.at(-1).rel;
  const pin=mkDestination();pin.scale.setScalar(2.2*pathScale);pin.position.set(dst.x*pathScale,0,dst.z*pathScale);
  arrowGroup.add(pin);

  // arrows per segment
  for(let i=0;i<waypoints.length-1;i++){
    const a=waypoints[i].rel,b=waypoints[i+1].rel;
    const dx=b.x-a.x,dz=b.z-a.z,len=Math.hypot(dx,dz);
    const arrows=Math.max(3,Math.floor(len/8));
    const yaw=Math.atan2(dx,dz);
    for(let j=0;j<arrows;j++){
      const t=(j+0.5)/arrows;
      const mesh=mkArrow();
      mesh.rotation.y=-yaw;
      mesh.scale.setScalar(4*pathScale);
      mesh.position.set((a.x+dx*t)*pathScale,0.02,(a.z+dz*t)*pathScale);
      arrowGroup.add(mesh);
    }
  }
  moveSceneToUser();
}

// ========== POSITION SCENE UNDER USER ==========
function moveSceneToUser(){
  if(!currentPosition||!waypoints.length) return;
  const delta=geoToXY(waypoints[0],currentPosition);
  arrowGroup.position.set(-delta.x*pathScale,0,-delta.z*pathScale);
}

// ========== HUD / ETA ==========
function updateHUD(){
  if(!currentPosition||!waypoints.length) return;
  const dest=waypoints.at(-1);
  const meters=metersBetween(currentPosition,dest);
  const km=meters/1000;
  const text=km<1?`${Math.round(meters)} m`:`${km.toFixed(1)} km`;
  const mins=Math.round(km*2);
  document.getElementById('distanceTime').textContent=`${text} • ${mins} min`;
  const eta=new Date();eta.setMinutes(eta.getMinutes()+mins);
  document.getElementById('eta').textContent=`ETA ${eta.toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'})}`;
}

// ========== RENDER LOOP ==========
function animate(){
  requestAnimationFrame(animate);
  // pulsing arrows
  arrowGroup.children.forEach(o=>{if(o.userData?.t!==undefined){o.userData.t+=0.05;o.scale.y=o.userData.base*(1+0.25*Math.sin(o.userData.t));}});
  renderer.render(scene,camera);
}

// ========== EVENT HOOKS ==========
function initUI(){
  window.addEventListener('resize',()=>{camera.aspect=innerWidth/innerHeight;camera.updateProjectionMatrix();renderer.setSize(innerWidth,innerHeight);});
  document.getElementById('recenterBtn').onclick=()=>camera.position.set(0,1.6,0);
  document.getElementById('calibrateBtn').onclick=()=>document.getElementById('calibrationPrompt').classList.add('show');
}
function hideCalibration(){document.getElementById('calibrationPrompt').classList.remove('show');}

// ========== APP ENTRY ==========
(async()=>{
  try{
    await initCamera();initThree();initDeviceOrientation();initGeolocation();initUI();
    const raw=await loadWaypoints();waypoints=prepWaypoints(raw);
    if(!waypoints.length)console.warn('No waypoints – append ?routeId=... to the URL');
    buildPath();animate();
  }catch(e){alert('Init failed: '+e.message);console.error(e);} })();

// allow iOS sensor permissions on first tap
function iosPerm(){if(DeviceOrientationEvent?.requestPermission)DeviceOrientationEvent.requestPermission();}
['touchstart','click'].forEach(ev=>document.addEventListener(ev,iosPerm,{once:true}));
</script>
</body>
</html>
