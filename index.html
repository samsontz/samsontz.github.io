<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>AR Navigation Demo</title>

  <!-- ─── Import map for Three.js ────────────────────────────── -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.155.0/build/three.module.js"
    }
  }
  </script>

  <style>
    html,body { margin:0; height:100%; overflow:hidden; background:#000; font-family:sans-serif; }
    #enter-ar {
      position:fixed; left:50%; bottom:2rem; transform:translateX(-50%);
      padding:.8rem 1.4rem; font-size:1rem; border:none; border-radius:8px;
      background:#ff4060; color:#fff; cursor:pointer; z-index:10;
    }
    #loading,#debug,#orientation {
      position:fixed; left:0; right:0; padding:.3rem .8rem;
      font-size:.85rem; background:rgba(0,0,0,.55); color:#0f0; pointer-events:none;
      white-space:pre-wrap; word-break:break-word; font-family:monospace;
    }
    #loading { top:0; text-align:center; background:#222; color:#fff; }
    #debug   { bottom:0; max-height:40%; overflow:auto; display:none; }
    #orientation { top:2.2rem; text-align:center; }
  </style>
</head>
<body>
  <button id="enter-ar">Enter AR</button>
  <div id="loading">Loading navigation…</div>
  <div id="debug"></div>
  <div id="orientation"></div>

  <script type="module">
    /* ──────────────────────────────────────────────────────────
       Imports & renderer / camera boiler-plate
    ────────────────────────────────────────────────────────── */
    import * as THREE from 'three';

    const scene    = new THREE.Scene();
    const camera   = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.01, 20);
    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
    renderer.xr.enabled = true;
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    /* Lights */
    scene.add(new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1));
    const dirLight = new THREE.DirectionalLight(0xffffff, .8);
    dirLight.position.set(0,5,3);
    scene.add(dirLight);

    /* Debug helper */
    const dbg = document.getElementById('debug');
    function log(msg){ console.log(msg); dbg.textContent += msg+'\n'; dbg.style.display='block'; }

    /* ---------- Geometry creators ---------- */
    function createRoadArrow(){
      const shape = new THREE.Shape()
        .moveTo( 0, 0.6)
        .lineTo(-0.4,-0.6)
        .lineTo( 0  ,-0.3)
        .lineTo( 0.4,-0.6)
        .lineTo( 0, 0.6);
      const geometry = new THREE.ShapeGeometry(shape);
      geometry.rotateX(-Math.PI/2);
      const material = new THREE.MeshStandardMaterial({ color:0xff2255, roughness:.5, metalness:.1 });
      return new THREE.Mesh(geometry, material);
    }

    function createDestinationMarker(){
      const coneGeo = new THREE.ConeGeometry(0.25, 0.4, 32);
      coneGeo.translate(0,-0.2,0).rotateX(Math.PI);
      const coneMat = new THREE.MeshStandardMaterial({ color:0xff2255 });
      const cone    = new THREE.Mesh(coneGeo, coneMat);

      const ringGeo = new THREE.RingGeometry(0.27, 0.3, 32).rotateX(-Math.PI/2);
      const ringMat = new THREE.MeshStandardMaterial({ color:0xff2255, side:THREE.DoubleSide });
      const ring    = new THREE.Mesh(ringGeo, ringMat);

      const grp = new THREE.Group();
      grp.add(cone, ring);
      return grp;
    }

    /* ---------- Waypoint helpers ---------- */
    async function loadWaypoints(){
      const id = new URLSearchParams(location.search).get('routeId');
      if(!id){ log('⚠ No routeId param in URL'); return []; }
      try{
        const res  = await fetch(`https://waypoints-prht.onrender.com/get-waypoints/${id}`);
        const data = await res.json();
        log(`Loaded ${data.waypoints?.length || 0} waypoints`);
        return data.waypoints || [];
      }catch(e){ log('Fetch error: '+e.message); return []; }
    }

    function addWaypointsToScene(wps){
      /* Clear previous meshes except lights */
      scene.children.slice().forEach(obj=>{
        if(!['HemisphereLight','DirectionalLight'].includes(obj.type)) scene.remove(obj);
      });
      wps.forEach((wp,i)=>{
        const mesh = (i === wps.length-1) ? createDestinationMarker() : createRoadArrow();
        mesh.position.set(0,0,-1.5*i-2);  // demo placement
        scene.add(mesh);
      });
    }

    /* ──────────────────────────────────────────────────────────
       New startAR(): requests the session itself
    ────────────────────────────────────────────────────────── */
    async function startAR(){
      /* Capability checks */
      if(!navigator.xr) throw Error('WebXR not supported in this browser.');
      if(!(await navigator.xr.isSessionSupported('immersive-ar')))
        throw Error('Device/browser lacks “immersive-ar” support.');

      /* Request session (prompts the user) */
      const sessionInit = {
        requiredFeatures:['hit-test'],
        optionalFeatures:['dom-overlay'],
        domOverlay:{ root:document.body }
      };
      const session = await navigator.xr.requestSession('immersive-ar', sessionInit);

      /* Hand over to Three.js */
      renderer.xr.setSession(session);

      /* Reticle */
      const reticle = new THREE.Mesh(
        new THREE.RingGeometry(0.15,0.2,32).rotateX(-Math.PI/2),
        new THREE.MeshBasicMaterial({ color:0x00ffff, opacity:.6, transparent:true })
      );
      scene.add(reticle); reticle.visible = false;

      /* Hit-test setup */
      const viewerSpace   = await session.requestReferenceSpace('viewer');
      const hitTestSource = await session.requestHitTestSource({ space:viewerSpace });

      const controller = renderer.xr.getController(0);
      controller.addEventListener('select', ()=>{
        if(reticle.visible){
          const mat = reticle.matrix.clone();
          scene.traverse(obj=>{
            if(obj !== reticle && !['HemisphereLight','DirectionalLight'].includes(obj.type)){
              obj.applyMatrix4(mat);
            }
          });
          reticle.visible = false;
        }
      });
      scene.add(controller);

      /* Render loop */
      renderer.setAnimationLoop((t,frame)=>{
        if(frame){
          const refSpace = renderer.xr.getReferenceSpace();
          const hits = frame.getHitTestResults(hitTestSource);
          if(hits.length){
            const pose = hits[0].getPose(refSpace);
            reticle.visible = true;
            reticle.matrix.fromArray(pose.transform.matrix);
            reticle.matrix.decompose(reticle.position, reticle.quaternion, reticle.scale);
          }else{
            reticle.visible = false;
          }
        }
        renderer.render(scene,camera);
      });
    }

    /* ---------- User gesture boot-strap ---------- */
    document.getElementById('enter-ar').addEventListener('click', async ()=>{
      try{
        await startAR();
        const wps = await loadWaypoints();
        addWaypointsToScene(wps);
        document.getElementById('enter-ar').style.display = 'none';
        document.getElementById('loading').style.display  = 'none';
      }catch(e){ log(e.message); }
    });

    /* ---------- Resize ---------- */
    window.addEventListener('resize', ()=>{
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });
  </script>
</body>
</html>
