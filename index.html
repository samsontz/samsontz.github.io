<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AR Navigation – Real‑time
    Tracking</title>
  <!-- Three.js ES‑module import map (pinned to a known‑good version) -->
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
  </script>
  <style>
    /* --- simple UI styling --- */
    body{margin:0;overflow:hidden;font-family:system-ui,Avenir,Helvetica,Arial,sans-serif}
    button{cursor:pointer;border:none;border-radius:4px;padding:12px 24px;font-size:16px}
    #enter-ar{position:absolute;top:10px;left:10px;z-index:999;background:#007bff;color:#fff}
    #enter-ar:hover{background:#0056b3}
    .panel{position:absolute;background:rgba(0,0,0,.75);color:#fff;padding:10px;border-radius:4px;font-size:12px;display:none}
    #loading{top:50%;left:50%;transform:translate(-50%,-50%);text-align:center;font-size:14px}
    #debug{bottom:10px;left:10px;max-width:80%;white-space:pre-wrap}
    #orientation{top:10px;right:10px;font-size:14px}
    #location-info{top:60px;right:10px}
  </style>
</head>
<body>
  <button id="enter-ar">Enter&nbsp;AR</button>
  <div id="loading" class="panel">Loading navigation…</div>
  <div id="debug" class="panel"></div>
  <div id="orientation" class="panel"></div>
  <div id="location-info" class="panel"></div>

  <script type="module">
    /* --- imports --- */
    import * as THREE from 'three';
    import { ARButton } from 'three/addons/webxr/ARButton.js';

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 40);
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.xr.enabled = true;
    document.body.appendChild(renderer.domElement);

    const debugEl       = document.getElementById('debug');
    const orientationEl = document.getElementById('orientation');
    const locationEl    = document.getElementById('location-info');
    const loadingEl     = document.getElementById('loading');

    const log = (msg)=>{ console.log(msg); debugEl.style.display='block'; debugEl.textContent += `${msg}\n`; };
    const clearLog = ()=>{ debugEl.textContent=''; };

    // lighting
    scene.add(new THREE.HemisphereLight(0xffffff,0xbbbbff,1));
    const dirLight = new THREE.DirectionalLight(0xffffff,0.8); dirLight.position.set(0,10,0); scene.add(dirLight);

    // state vars
    let watchId           = null;   // geolocation watcher
    let currentPosition   = null;   // {lat,lng,heading,accuracy}
    let smoothedHeading   = null;   // low‑pass filtered heading (deg)
    let waypoints         = [];     // full route from server (raw lat/lng)
    let arObjects         = [];     // THREE.Object3D[] placed for current frame
    const WORLD_SCALE     = 0.05;   // 1m IRL –> 5 cm in scene

    const EARTH_RADIUS = 6371000; // metres

    function haversine(lat1,lon1,lat2,lon2){
      const φ1=THREE.MathUtils.degToRad(lat1), φ2=THREE.MathUtils.degToRad(lat2);
      const Δφ=THREE.MathUtils.degToRad(lat2-lat1), Δλ=THREE.MathUtils.degToRad(lon2-lon1);
      const a=Math.sin(Δφ/2)**2 + Math.cos(φ1)*Math.cos(φ2)*Math.sin(Δλ/2)**2;
      return EARTH_RADIUS * 2*Math.atan2(Math.sqrt(a),Math.sqrt(1-a));
    }

    function latLngToOffset(lat1,lon1,lat2,lon2){
      // Returns east‑west (x) & north‑south (z) offsets in metres.
      const φ1=THREE.MathUtils.degToRad(lat1), φ2=THREE.MathUtils.degToRad(lat2);
      const Δφ=THREE.MathUtils.degToRad(lat2-lat1), Δλ=THREE.MathUtils.degToRad(lon2-lon1);
      const x = EARTH_RADIUS * Δλ * Math.cos((φ1+φ2)/2); // east
      const z = EARTH_RADIUS * Δφ;                        // north
      return {x,z};
    }

    const HEADING_SMOOTH_ALPHA = 0.15;
    function smoothHeading(raw){
      if(smoothedHeading===null || isNaN(smoothedHeading)) { smoothedHeading = raw; }
      const Δ = ((raw - smoothedHeading + 540) % 360) - 180; // shortest Δ, handling wraparound
      smoothedHeading = (smoothedHeading + HEADING_SMOOTH_ALPHA * Δ + 360) % 360;
      return smoothedHeading;
    }

    function makeArrow(){
      const shape = new THREE.Shape().moveTo(-0.5,-0.5).lineTo(0,0.5).lineTo(0.5,-0.5).lineTo(-0.5,-0.5);
      const geo = new THREE.ShapeGeometry(shape);
      const mat = new THREE.MeshStandardMaterial({color:0xffff00,emissive:0xffff00,transparent:true,opacity:0.9,side:THREE.DoubleSide,emissiveIntensity:0.5});
      const mesh = new THREE.Mesh(geo,mat);
      mesh.rotation.x = -Math.PI/2;
      mesh.scale.set(0.3,0.3,0.3);
      return mesh;
    }

    function makeDestinationMarker(){
      const group = new THREE.Group();
      const redMat = new THREE.MeshStandardMaterial({color:0xb01020,emissive:0xb01020,emissiveIntensity:0.3});
      const whiteMat = new THREE.MeshStandardMaterial({color:0xffffff,emissive:0xffffff,emissiveIntensity:0.3});
      const top   = new THREE.Mesh(new THREE.CylinderGeometry(0.4,0.3,0.6,6), redMat);
      const inner = new THREE.Mesh(new THREE.CylinderGeometry(0.15,0.15,0.1,6), whiteMat); inner.position.y = 0.31;
      const tip   = new THREE.Mesh(new THREE.ConeGeometry(0.1,0.4,16), redMat); tip.position.y = -0.4;
      group.add(top,inner,tip);
      group.position.y = 1.0;
      return group;
    }

    function updateAR(){
      if(!currentPosition || !waypoints.length) return;

      // dispose & remove previous overlays
      arObjects.forEach(obj=>{
        scene.remove(obj);
        if(obj.geometry) obj.geometry.dispose();
        if(obj.material){ (Array.isArray(obj.material)?obj.material:[obj.material]).forEach(m=>m.dispose()); }
      });
      arObjects.length = 0;

      // find closest waypoint ahead
      let closestIndex = 0, minDist = Infinity;
      for(let i=0;i<waypoints.length;i++){
        const d = haversine(currentPosition.lat,currentPosition.lng, waypoints[i].lat,waypoints[i].lng);
        if(d < minDist){ minDist=d; closestIndex=i; }
      }
      const ahead = waypoints.slice(closestIndex); if(!ahead.length) return;

      // build local coordinate list relative to current device location
      const headingRad = THREE.MathUtils.degToRad(currentPosition.heading||0);
      const cosH = Math.cos(headingRad), sinH = Math.sin(headingRad);
      const local = ahead.map(wp=>{
        const {x,z} = latLngToOffset(currentPosition.lat,currentPosition.lng, wp.lat,wp.lng);
        // rotate so device forward == -Z
        return {
          x:  x * cosH - z * sinH,
          z:  x * sinH + z * cosH
        };
      });

      // destination pin (last local coord)
      const destLocal = local[local.length-1];
      const dest = makeDestinationMarker();
      dest.position.set(destLocal.x*WORLD_SCALE, 0, destLocal.z*WORLD_SCALE);
      scene.add(dest); arObjects.push(dest);

      // arrows along segments (spacing ~4 m)
      const ARROW_SPACING = 4; // metres

      for(let i=0;i<local.length-1;i++){
        const a = local[i], b = local[i+1];
        const dx = b.x - a.x, dz = b.z - a.z;
        const segLen = Math.hypot(dx,dz);
        const steps = Math.max(1,Math.floor(segLen/ARROW_SPACING));
        const yaw   = Math.atan2(dx,dz); // rotate so arrow points travel dir
        for(let s=0;s<steps;s++){
          const t = (s+0.5)/steps;
          const x = (a.x + dx*t) * WORLD_SCALE;
          const z = (a.z + dz*t) * WORLD_SCALE;
          const arrow = makeArrow();
          arrow.position.set(x, 0.05, z);
          arrow.rotation.y = -yaw; // scene forward = -Z
          scene.add(arrow);
          arObjects.push(arrow);
        }
      }
    }

    function startGeolocation(){
      if(watchId!==null) return; // already running
      if(!navigator.geolocation){ log('Geolocation not supported'); return; }
      watchId = navigator.geolocation.watchPosition(pos=>{
        if(pos.coords.accuracy>25){ // ignore very inaccurate fixes (>25 m)
          log(`Ignored inaccurate fix (${pos.coords.accuracy.toFixed(0)} m)`);
          return;
        }
        currentPosition = {
          lat: pos.coords.latitude,
          lng: pos.coords.longitude,
          accuracy: pos.coords.accuracy,
          heading: Number.isFinite(pos.coords.heading)? pos.coords.heading : (currentPosition?.heading ?? 0)
        };
        // UI update
        locationEl.innerHTML = `Lat: ${currentPosition.lat.toFixed(6)}<br>Lng: ${currentPosition.lng.toFixed(6)}<br>Acc: ${currentPosition.accuracy.toFixed(1)} m<br>Heading: ${currentPosition.heading.toFixed(0)}°`;
        locationEl.style.display='block';
        updateAR();
      }, err=>log(`Geolocation error: ${err.message}`), { enableHighAccuracy:true, maximumAge:1000, timeout:10000 });
    }

    async function initOrientation(){
      if(typeof DeviceOrientationEvent==='undefined'){ log('Orientation API not available'); return; }
      if(typeof DeviceOrientationEvent.requestPermission==='function'){
        try{
          const p = await DeviceOrientationEvent.requestPermission();
          if(p !== 'granted'){ log('Orientation permission denied'); return; }
        }catch(e){ log(`Orientation permission error: ${e.message}`); return; }
      }
      window.addEventListener('deviceorientationabsolute', handleOrientation, true);
      window.addEventListener('deviceorientation',          handleOrientation, true);
    }

    function handleOrientation(evt){
      if(evt.absolute===false && evt.alpha===null) return; // unsupported
      const raw = (evt.webkitCompassHeading !== undefined)
                    ? evt.webkitCompassHeading // iOS gives 0° = north already
                    : (360 - evt.alpha);       // others: alpha 0° = north‑clockwise
      const hdg = smoothHeading(raw);
      smoothedHeading = hdg;
      orientationEl.textContent = `Heading: ${hdg.toFixed(0)}°`;
      orientationEl.style.display='block';
      if(currentPosition){ currentPosition.heading = hdg; updateAR(); }
    }

    async function fetchWaypoints(){
      const routeId = new URLSearchParams(location.search).get('routeId');
      if(!routeId){ throw new Error('No routeId param'); }
      const res = await fetch(`https://waypoints-prht.onrender.com/get-waypoints/${routeId}`);
      const js  = await res.json();
      if(!js.waypoints?.length) throw new Error('No waypoints returned');
      return js.waypoints.filter(w=>w.lat&&w.lng);
    }

    let reticle = null;
    async function startAR(){
      if(!('xr' in navigator)) throw new Error('WebXR not supported');
      if(!(await navigator.xr.isSessionSupported('immersive-ar'))) throw new Error('AR not supported on this device');

      // reticle for ground placement
      reticle = new THREE.Mesh(new THREE.RingGeometry(0.15,0.2,32).rotateX(-Math.PI/2), new THREE.MeshBasicMaterial({color:0xffffff,opacity:0.6,transparent:true}));
      reticle.visible = false; scene.add(reticle);

      const arBtn = ARButton.createButton(renderer,{ requiredFeatures:['hit-test'], optionalFeatures:['dom-overlay'], domOverlay:{root:document.body} });
      document.body.appendChild(arBtn);

      let hitSrc=null,hitRequested=false;
      renderer.xr.addEventListener('sessionend',()=>{ hitSrc=null; hitRequested=false; if(watchId!==null){ navigator.geolocation.clearWatch(watchId); watchId=null; } });

      renderer.setAnimationLoop((t,frame)=>{
        if(frame){
          const sess = renderer.xr.getSession();
          if(!hitRequested){
            sess.requestReferenceSpace('viewer').then(ref=> sess.requestHitTestSource({space:ref}).then(src=>hitSrc=src));
            hitRequested=true; sess.addEventListener('end',()=>{hitSrc=null;hitRequested=false;});
          }
          if(hitSrc){
            const refSpace = renderer.xr.getReferenceSpace();
            const hits = frame.getHitTestResults(hitSrc);
            if(hits.length){ reticle.visible=true; reticle.matrix.fromArray(hits[0].getPose(refSpace).transform.matrix); }
            else { reticle.visible=false; }
          }
        }
        renderer.render(scene,camera);
      });
    }

    document.getElementById('enter-ar').addEventListener('click', async ()=>{
      try{
        loadingEl.style.display='block'; clearLog();
        await startAR();
        await initOrientation();
        waypoints = await fetchWaypoints();
        log(`Waypoints loaded: ${waypoints.length}`);
        startGeolocation();
        loadingEl.style.display='none';
        document.getElementById('enter-ar').style.display='none';
      }catch(e){ loadingEl.textContent = `Error: ${e.message}`; log(`Init error: ${e.message}`); }
    });

    window.addEventListener('resize',()=>{
      if(!renderer.xr.isPresenting){ camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth,window.innerHeight); }
    });

    document.addEventListener('visibilitychange',()=>{
      if(document.hidden && watchId!==null){ navigator.geolocation.clearWatch(watchId); watchId=null; }
      else if(!document.hidden && watchId===null){ startGeolocation(); }
    });
  </script>
</body>
</html>
