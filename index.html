<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ARÂ NavigationÂ â€“Â Waypoint EditionÂ (v7.1Â â€¢ GPSâ€‘fix)</title>

  <!-- Three.js (quick nonâ€‘module build) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

  <style>
    /* ------------ UI & layout ------------ */
    *{margin:0;padding:0;box-sizing:border-box}
    body{font-family:"Segoe UI",Tahoma,Geneva,Verdana,sans-serif;background:#000;color:#fff;overflow:hidden}
    #video,#canvas{position:absolute;inset:0;width:100vw;height:100vh}
    #canvas{pointer-events:none;z-index:2}
    #video{object-fit:cover;z-index:1}

    .ui-overlay{position:absolute;z-index:3;font-weight:500}
    .top-bar{top:20px;left:20px;right:20px;display:flex;justify-content:space-between;align-items:center;padding:14px 20px;border-radius:22px;backdrop-filter:blur(8px);background:rgba(0,0,0,.45)}
    .distance-time{font-size:18px;font-weight:600}.eta{font-size:14px;opacity:.8}
    .compass{width:50px;height:50px;border:2px solid rgba(255,255,255,.6);border-radius:50%;display:flex;align-items:center;justify-content:center}
    .compass-needle{width:3px;height:20px;background:#4285f4;border-radius:2px;transform-origin:bottom center;transition:transform .3s}
    .bottom-controls{bottom:22px;left:20px;right:20px;display:flex;justify-content:space-between;align-items:center}
    .control-btn{width:55px;height:55px;border-radius:50%;background:rgba(0,0,0,.8);backdrop-filter:blur(8px);display:flex;align-items:center;justify-content:center;font-size:25px;transition:.25s}
    .control-btn:hover{background:rgba(255,255,255,.3);transform:scale(1.1)}
    .center-crosshair{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);width:18px;height:18px;border:2px solid rgba(255,255,255,.6);border-radius:50%;z-index:4;pointer-events:none}

    /* simple helper so we can toggle visibility cleanly */
    .hidden{display:none !important}
  </style>
</head>
<body>
  <video id="video" playsinline autoplay muted></video>
  <canvas id="canvas"></canvas>

  <!-- ---------------- UI overlays ---------------- -->
  <div class="ui-overlay top-bar">
    <div class="distance-time"><span id="distanceTime" class="distance-time">â€”</span><br><span id="eta" class="eta">â€”</span></div>
    <div class="compass"><div id="compassNeedle" class="compass-needle"></div></div>
  </div>
  <div class="ui-overlay bottom-controls">
    <div id="recenterBtn" class="control-btn">â¦¿</div>
    <div id="themeBtn"    class="control-btn">â˜¾</div>
  </div>
  <div class="center-crosshair"></div>

  <!-- translucent status panel -->
  <div id="overlay" class="ui-overlay" style="top:50%;left:50%;transform:translate(-50%,-50%);text-align:center;backdrop-filter:blur(6px);background:rgba(0,0,0,.55);padding:25px 40px;border-radius:18px">
    <p id="pMsg">ðŸ“¡Â SearchingÂ GPSâ€¦</p>
  </div>

  <!-- ---------------- Main script ---------------- -->
<script>
/****************************************** GLOBALS *****/
let renderer, scene, camera, gArrows;
let current=null, base=null;              // gps points
let fetched=[],   wps=[];                 // server + merged wayâ€‘points
let scale=0.1;                            // metres â†’ scene units (tweak if arrows too close/far)
let geoOK=false, wapOK=false;
let geoWatchId=null;                      // id for clearWatch if needed

const API = 'https://waypoint-server.example/route/';

/************************************* UTILITY HELPERS *****/
const toRad   = d=>d*Math.PI/180;
const toDeg   = r=>r*180/Math.PI;
const dist    = (a,b)=>{
  const R=6371000, Ï†1=toRad(a.lat), Ï†2=toRad(b.lat), Î”Ï†=toRad(b.lat-a.lat), Î”Î»=toRad(b.lng-a.lng);
  const s=Math.sin(Î”Ï†/2)**2+Math.cos(Ï†1)*Math.cos(Ï†2)*Math.sin(Î”Î»/2)**2;
  return 2*R*Math.atan2(Math.sqrt(s),Math.sqrt(1-s));
};
const bearing = (a,b)=>{
  const Ï†1=toRad(a.lat), Ï†2=toRad(b.lat), Î”Î»=toRad(b.lng-a.lng);
  const y=Math.sin(Î”Î»)*Math.cos(Ï†2);
  const x=Math.cos(Ï†1)*Math.sin(Ï†2)-Math.sin(Ï†1)*Math.cos(Ï†2)*Math.cos(Î”Î»);
  return (toDeg(Math.atan2(y,x))+360)%360;
};
const toXY    = (o,p)=>{
  const d=dist(o,p); const brg=toRad(bearing(o,p));
  return {x: Math.sin(brg)*d, z: Math.cos(brg)*d};
};

/************************************ OVERLAY HELPERS *****/
function setOverlay(msg){ pMsg.textContent=msg; overlay.classList.remove('hidden'); }
function hideOverlay(){ overlay.classList.add('hidden'); }

/******************************** CAMERA & THREE ******* */
async function initCamera(){
  const stream=await navigator.mediaDevices.getUserMedia({video:{facingMode:{ideal:'environment'}}});
  video.srcObject=stream; await video.play();
}
function initThree(){
  renderer=new THREE.WebGLRenderer({canvas,alpha:true});
  renderer.setSize(innerWidth,innerHeight);
  scene=new THREE.Scene();
  camera=new THREE.PerspectiveCamera(60,innerWidth/innerHeight,0.1,1000);
  camera.position.set(0,1.4,0);
  scene.add(new THREE.AmbientLight(0xffffff,1.1));
  window.addEventListener('resize',()=>{
    camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix();
    renderer.setSize(innerWidth,innerHeight);
  });
}

/********************************* DEVICE ORIENTATION ****/ 
function initOrientation(){
  // we purposely request permission on iOS 13+ (not required on Chrome/Android)
  if(typeof DeviceOrientationEvent!=='undefined' && typeof DeviceOrientationEvent.requestPermission==='function'){
    DeviceOrientationEvent.requestPermission().catch(()=>{});
  }
  window.addEventListener('deviceorientation',e=>{
    if(e.absolute===false && e.alpha===null) return; // sensor unavailable
    const heading = e.webkitCompassHeading || (360 - e.alpha); // unify iOS / Android
    compassNeedle.style.transform=`rotate(${heading}deg)`;
    if(gArrows) gArrows.rotation.y=toRad(-heading);
  });
}

/******************************** GEOLOCATION ***********/
function initGeo(){
  if(!('geolocation' in navigator)){
    throw new Error('This device does not support Geolocation.');
  }

  // Quick coarse fix to unblock UI fast
  navigator.geolocation.getCurrentPosition(handleFix, err=>{
    console.warn('[geo] quick fix failed', err);
  }, {
    enableHighAccuracy:false,
    timeout:5000,
    maximumAge:60000
  });

  // Highâ€‘accuracy continuous watch for refinement
  geoWatchId = navigator.geolocation.watchPosition(handleFix, handleGeoError, {
    enableHighAccuracy:true,
    timeout:15000,
    maximumAge:3000
  });
}
function handleFix(pos){
  current = { lat: pos.coords.latitude, lng: pos.coords.longitude };

  // first ever fix becomes base/origin
  if(!base){
    base = { ...current };
    geoOK = true;
    tryBuild();
  }

  // update UI & scene (safeâ€‘guard if scene not yet built)
  uiUpdate();
  shiftScene();

  // If GPS ready but waypoints still brewing, update status
  if(geoOK && !wapOK){
    setOverlay('ðŸ“¦Â LoadingÂ routeâ€¦');
  }
}
function handleGeoError(err){
  console.error('[geo] watch error', err);
  if(err.code === err.PERMISSION_DENIED){
    setOverlay('âš ï¸Â LocationÂ permissionÂ denied. Enable GPS to continue.');
  }
}

/******************************** WAYâ€‘POINT FETCH *******/
async function fetchWps(){
  const id=new URLSearchParams(location.search).get('routeId');
  if(!id){ throw new Error('Missing ?routeId=â€¦ in URL.'); }

  const res=await fetch(API+id);
  if(!res.ok){ throw new Error('Waypointâ€‘server responded with '+res.status); }

  const data=await res.json();
  if(!Array.isArray(data.waypoints) || !data.waypoints.length){
    throw new Error('Route has no wayâ€‘points.');
  }
  fetched=data.waypoints;
  wapOK=true;
  tryBuild();
}

/********************************* SCENE CREATION ******/
function meshArrow(){
  const g=new THREE.Group();
  const shaft=new THREE.Mesh(new THREE.CylinderGeometry(0.06,0.06,1,8),new THREE.MeshLambertMaterial({color:0x00ff40}));
  shaft.rotation.x=Math.PI/2; shaft.position.z=-0.5; g.add(shaft);
  const head=new THREE.Mesh(new THREE.ConeGeometry(0.14,0.25,8),new THREE.MeshLambertMaterial({color:0x00ff40}));
  head.rotation.x=Math.PI/2; head.position.z=-1; g.add(head);
  return g;
}
function prepareWP(){
  // Convert serverâ€‘waypoints to enriched objects + tack on final destination (= origin point) if necessary
  wps = [
    ...fetched.map(wp=>({...wp, mesh: meshArrow()})),
  ];
}
function buildScene(){
  gArrows = new THREE.Group();
  wps.forEach(wp=>gArrows.add(wp.mesh));
  scene.add(gArrows);
  hideOverlay();
}

/********************************* RUNTIME UPDATES *****/
function shiftScene(){
  if(!current || !gArrows) return; // wait until scene is built
  const d = toXY(base, current);
  gArrows.position.set(-d.x*scale, 0, -d.z*scale);
}
function uiUpdate(){
  if(!current || !wps.length) return;
  const m = dist(current, wps[wps.length-1]); // distance to final waypoint
  const km = m/1000;
  distanceTime.textContent = `${ km < 1 ? Math.round(m)+'Â m' : km.toFixed(1)+'Â km' } â€¢ ${ Math.round(km*2) }Â min`;
  const ETA = new Date(); ETA.setMinutes(ETA.getMinutes()+Math.round(km*2));
  eta.textContent = `ETAÂ ${ ETA.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'}) }`;
}

/*********************************** RENDER LOOP ******/
function loop(){
  requestAnimationFrame(loop);
  if(renderer && camera && scene){ renderer.render(scene,camera); }
}

/************************************** GATEKEEPER ****/
function tryBuild(){
  if(geoOK && wapOK){
    prepareWP();
    buildScene();
  }
}

/***************************************** APP BOOT ***/
async function startApp(){
  try{
    await initCamera();
    initThree();
    initOrientation();
    initGeo();
    await fetchWps();
    loop();
  }catch(e){
    console.error(e);
    setOverlay('âŒÂ '+e.message);
  }
}

/************************* HTTPS GUARD + KICKâ€‘OFF *****/
if(location.protocol !== 'https:'){
  setOverlay('ðŸ”’Â Please open this demo over HTTPS to access camera & location sensors.');
}else{
  startApp();
}
</script>
</body>
</html>
