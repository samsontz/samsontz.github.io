<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta
    name="viewport"
    content="width=device-width,initial-scale=1.0">
  <title>AR Navigation – Real-time Tracking</title>

  <!-- Three.js ES-module import map (pinned to a known-good version) -->
  <script type="importmap">
    {
      "imports": {
        "three":            "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/":    "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
  </script>

  <!-- Google Maps (v = 3-D Maps API) – replace YOUR_API_KEY ↓↓↓ -->
  <script
    src="https://maps.googleapis.com/maps/api/js?key=YOUR_API_KEY&libraries=maps">
  </script>

  <style>
    /* ------- basic UI -------- */
    body{margin:0;overflow:hidden;font-family:system-ui,Avenir,Helvetica,Arial,sans-serif}

    button,select{cursor:pointer;border:none;border-radius:4px;padding:12px 24px;font-size:16px}

    #enter-ar    {position:absolute;top:10px;left:10px;z-index:999;background:#007bff;color:#fff}
    #enter-ar:hover{background:#0056b3}

    .panel       {position:absolute;background:rgba(0,0,0,.75);color:#fff;padding:10px;border-radius:4px;font-size:12px;display:none}
    #loading     {top:50%;left:50%;transform:translate(-50%,-50%);text-align:center;font-size:14px}
    #debug       {bottom:10px;left:10px;max-width:80%;white-space:pre-wrap}
    #orientation {top:10px;right:10px;font-size:14px}
    #location-info{top:60px;right:10px}

    /* ------- NEW: map & mode switcher -------- */
    #modeToggle  {position:absolute;top:10px;right:10px;z-index:1000}

    #mapContainer{position:absolute;left:0;bottom:0;width:100%;height:30%;display:none;pointer-events:auto}
    body.map-on  #mapContainer {display:block}
    body.map-only #mapContainer{height:100%}

  </style>
</head>
<body>

  <button id="enter-ar">Enter AR</button>

  <!-- NEW: display-mode switcher -->
  <select id="modeToggle">
    <option value="fullAR">Full AR</option>
    <option value="hybrid">AR + 2D</option>
    <option value="mapOnly">2D only</option>
  </select>

  <!-- NEW: Google Maps mini-map -->
  <div id="mapContainer"></div>

  <!-- status / debug panels -->
  <div id="loading"        class="panel">Loading navigation…</div>
  <div id="debug"          class="panel"></div>
  <div id="orientation"    class="panel"></div>
  <div id="location-info"  class="panel"></div>

  <script type="module">
    /* ---------- imports ---------- */
    import * as THREE     from 'three';
    import { ARButton }   from 'three/addons/webxr/ARButton.js';

    /* ---------- scene setup ---------- */
    const scene    = new THREE.Scene();
    const camera   = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.01, 40);
    const renderer = new THREE.WebGLRenderer({antialias:true,alpha:true});
    renderer.setPixelRatio(devicePixelRatio);
    renderer.setSize(innerWidth,innerHeight);
    renderer.xr.enabled = true;
    document.body.appendChild(renderer.domElement);

    /* ---------- UI handles ---------- */
    const debugEl       = document.getElementById('debug');
    const orientationEl = document.getElementById('orientation');
    const locationEl    = document.getElementById('location-info');
    const loadingEl     = document.getElementById('loading');
    const modeToggle    = document.getElementById('modeToggle');

    const log=(m)=>{console.log(m);debugEl.style.display='block';debugEl.textContent+=m+'\n';};
    const clearLog = ()=>{debugEl.textContent='';};

    /* ---------- lighting ---------- */
    scene.add(new THREE.HemisphereLight(0xffffff,0xbbbbff,1));
    const dirLight=new THREE.DirectionalLight(0xffffff,0.8);dirLight.position.set(0,10,0);scene.add(dirLight);

    /* ---------- state ---------- */
    let reticle            = null;
    let currentPosition    = null;             // {lat,lng,heading,accuracy}
    let watchId            = null;
    let waypoints          = [];               // full route
    const arObjects        = [];               // THREE objects for this frame
    const WORLD_SCALE      = 0.05;             // 1 m IRL → 5 cm in Three units

    /* ---------- helper: Haversine ---------- */
    const EARTH_RADIUS = 6_378_137;            // metres
    function haversine(lat1,lng1,lat2,lng2){
      const φ1=THREE.MathUtils.degToRad(lat1), φ2=THREE.MathUtils.degToRad(lat2);
      const Δφ=THREE.MathUtils.degToRad(lat2-lat1), Δλ=THREE.MathUtils.degToRad(lng2-lng1);
      const a=Math.sin(Δφ/2)**2 + Math.cos(φ1)*Math.cos(φ2)*Math.sin(Δλ/2)**2;
      return EARTH_RADIUS*2*Math.atan2(Math.sqrt(a),Math.sqrt(1-a));
    }
    /* ---------- lat/lng → planar offset ---------- */
    function latLngToOffset(lat1,lng1,lat2,lng2){
      const φ1=THREE.MathUtils.degToRad(lat1), φ2=THREE.MathUtils.degToRad(lat2);
      const Δφ=THREE.MathUtils.degToRad(lat2-lat1), Δλ=THREE.MathUtils.degToRad(lng2-lng1);
      const x = EARTH_RADIUS * Δλ * Math.cos((φ1+φ2)/2); // east-west
      const z = EARTH_RADIUS * Δφ;                        // north-south
      return {x,z};
    }

    /* ---------- simple arrow & destination markers ---------- */
    function makeArrow(){
      const g=new THREE.ConeGeometry(0.2,0.4,6), m=new THREE.MeshStandardMaterial({color:0x0099ff});
      const c=new THREE.Mesh(g,m); g.translate(0,0.2,0); return c;
    }
    function makeDestinationMarker(){
      const g=new THREE.CylinderGeometry(0.15,0.15,0.02,16);
      const m=new THREE.MeshStandardMaterial({color:0xff4444});
      return new THREE.Mesh(g,m);
    }

    /* ---------- NEW: Google Maps mini-map ---------- */
    let gMap=null, gPath=null;
    function initMiniMap(){
      gMap = new google.maps.Map(document.getElementById('mapContainer'),{
        zoom:18, tilt:67, heading:0,
        mapTypeId:'satellite', mapId:'a3d',
        center:{lat:currentPosition.lat,lng:currentPosition.lng},
        disableDefaultUI:true
      });
      gPath=new google.maps.Polyline({map:gMap,strokeWeight:6});
    }
    function redrawMiniMap(){
      if(!gMap) return;
      gMap.setCenter({lat:currentPosition.lat,lng:currentPosition.lng});
      gMap.setHeading(currentPosition.heading||0);
      gPath.setPath(waypoints.map(w=>({lat:w.lat,lng:w.lng})));
    }

    /* ---------- build the AR overlay each frame ---------- */
    function updateAR(){
      if(!currentPosition||!waypoints.length) return;

      /* clear previous frame */
      arObjects.forEach(o=>{
        scene.remove(o);
        o.geometry?.dispose();
        if(o.material){
          (Array.isArray(o.material)?o.material:[o.material]).forEach(m=>m.dispose());
        }
      });
      arObjects.length=0;

      /* ---- 1. live-location inserted at head of path ---- */
      const path = [{lat:currentPosition.lat,lng:currentPosition.lng}, ...waypoints];

      /* ---- find the nearest *ahead* point in that path ---- */
      let closestIndex=0, minDist=Infinity;
      for(let i=0;i<path.length;i++){
        const d=haversine(currentPosition.lat,currentPosition.lng,path[i].lat,path[i].lng);
        if(d<minDist){minDist=d;closestIndex=i;}
      }
      const ahead=path.slice(closestIndex);   // always ≥1 (starts with phone)
      if(ahead.length<2) return;              // nothing to draw if only phone

      /* ---- device-centric local coords ---- */
      const headingRad=THREE.MathUtils.degToRad(currentPosition.heading||0);
      const cosH=Math.cos(headingRad), sinH=Math.sin(headingRad);

      const local=ahead.map(w=>{
        const {x,z}=latLngToOffset(currentPosition.lat,currentPosition.lng,w.lat,w.lng);
        /* rotate to camera-space & flip Z so “forward” = −Z */
        return{
          x:  x*cosH - z*sinH,
          z: (x*sinH + z*cosH) * -1      // << SIGN FLIP FIXES WRONG-WAY ARROWS
        };
      });

      /* ---- destination pin ---- */
      const destLocal = local[local.length-1];
      const dest = makeDestinationMarker();
      dest.position.set(destLocal.x*WORLD_SCALE,0,destLocal.z*WORLD_SCALE);
      scene.add(dest); arObjects.push(dest);

      /* ---- arrows along path ---- */
      const ARROW_SPACING = 4;                        // metres
      for(let i=0;i<local.length-1;i++){
        const a=local[i], b=local[i+1];
        const dx=b.x-a.x, dz=b.z-a.z;
        const segLen=Math.hypot(dx,dz);
        const steps=Math.max(1,Math.floor(segLen/ARROW_SPACING));
        const yaw=Math.atan2(dx,dz);                  // travel direction
        for(let s=0;s<steps;s++){
          const t=(s+0.5)/steps;
          const px=(a.x+dx*t)*WORLD_SCALE;
          const pz=(a.z+dz*t)*WORLD_SCALE;
          const arrow=makeArrow();
          arrow.position.set(px,0.05,pz);
          arrow.rotation.y=-yaw;                      // scene forward = −Z
          scene.add(arrow); arObjects.push(arrow);
        }
      }
    }

    /* ---------- geolocation ---------- */
    function startGeolocation(){
      if(watchId!==null) return;                      // already running
      if(!navigator.geolocation){log('Geolocation not supported');return;}

      watchId=navigator.geolocation.watchPosition(pos=>{
        if(pos.coords.accuracy>25){                   // discard bad fixes (>25 m)
          log(`Ignored inaccurate fix (${pos.coords.accuracy.toFixed(0)} m)`);
          return;
        }
        currentPosition={
          lat:pos.coords.latitude,
          lng:pos.coords.longitude,
          accuracy:pos.coords.accuracy,
          heading:Number.isFinite(pos.coords.heading)
                  ?pos.coords.heading
                  :(currentPosition?.heading??0)
        };
        locationEl.innerHTML=
          `Lat ${currentPosition.lat.toFixed(5)}<br>`+
          `Lng ${currentPosition.lng.toFixed(5)}<br>`+
          `Heading ${currentPosition.heading.toFixed(0)}°`;
        locationEl.style.display='block';

        updateAR();
        redrawMiniMap();                              // NEW
      }, err=>log(`Geolocation error: ${err.message}`),
      {enableHighAccuracy:true,maximumAge:1_000,timeout:10_000});
    }

    /* ---------- orientation permission helper ---------- */
    async function initOrientation(){
      if(typeof DeviceOrientationEvent==='undefined') return;
      if(DeviceOrientationEvent.requestPermission){
        try{await DeviceOrientationEvent.requestPermission();}
        catch{log('Orientation permission denied');}
      }
    }

    /* ---------- route loader ---------- */
    async function fetchWaypoints(){
      const routeId=new URLSearchParams(location.search).get('routeId');
      if(!routeId) throw new Error('No routeId param');
      const res=await fetch(`https://waypoints-prht.onrender.com/get-waypoints/${routeId}`);
      const js =await res.json();
      if(!js.waypoints?.length) throw new Error('No waypoints returned');
      return js.waypoints.filter(w=>w.lat&&w.lng);
    }

    /* ---------- mode toggle ---------- */
    modeToggle.addEventListener('change',e=>{
      const v=e.target.value;
      document.body.classList.toggle('map-on',  v!=='fullAR');
      document.body.classList.toggle('map-only',v==='mapOnly');
      renderer.domElement.style.display = (v==='mapOnly')?'none':'block';
      if(v!=='fullAR' && !gMap && currentPosition) initMiniMap();
    });

    /* ---------- AR session + boot-strap ---------- */
    async function startAR(){
      if(!('xr' in navigator))          throw new Error('WebXR not supported');
      if(!(await navigator.xr.isSessionSupported('immersive-ar')))
        throw new Error('AR not supported on this device');

      /* reticle (optional ground-lock) */
      const geoPlane=new THREE.PlaneGeometry(1,1);
      const geoMat  =new THREE.MeshBasicMaterial({color:0xffff00,opacity:0.5,transparent:true});
      reticle=new THREE.Mesh(geoPlane,geoMat);
      reticle.rotateX(-Math.PI/2); scene.add(reticle);

      /* enter XR */
      const session=await navigator.xr.requestSession('immersive-ar',{requiredFeatures:['local-floor','hit-test']});
      renderer.xr.setSession(session);
      renderer.setAnimationLoop(()=>renderer.render(scene,camera));

      clearLog();
    }

    document.getElementById('enter-ar').addEventListener('click',startAR);

    /* ---------- boot ---------- */
    (async()=>{
      try{
        await initOrientation();
        waypoints = await fetchWaypoints();
        log(`Waypoints loaded: ${waypoints.length}`);
        redrawMiniMap();                // NEW – draws route when not in AR
        startGeolocation();
        loadingEl.style.display='none';
      }catch(err){
        loadingEl.textContent = err.message;
      }
    })();

  </script>
</body>
</html>
